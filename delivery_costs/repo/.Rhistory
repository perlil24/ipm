index_dt[, impacted_old := 0]
index_dt[index_new>=threshold_val, impacted_new := 1]
index_dt[index_old>=threshold_val, impacted_old := 1]
index_dt[, dropout := as.factor(impacted_old - impacted_new)]
index_dt[, GEOID10 := as.character(geocode)]
#merge the dropouts back onto the other tables for graphing
measure_ranks <- merge(measure_ranks, index_dt[, .(geocode, dropout)], by='geocode')
#drop water codes with weird data from maps
drop_geocodes <- c('53057990100' #san juan water area with lots of big changes
)
#add life expectancy data
index_dt[, geocode_chr := geocode %>% as.character]
index_dt <- merge(index_dt, le_dt, by.x='geocode_chr', by.y='geocode')
index_dt[, le_state_average := mean(le, na.rm=T)]
# ---FUNCTIONS----------------------------------------------------------------------------------------------------------
#test space
cleanAndRank <- function(dir, path,
nranks=10,
clean_names=F,
debug=F) {
if(debug) browser()
# File Details:
# Weights: Measures: All 1's = No Special Weights
#          Themes: "Environmental Effects" = .5, Other Themes Are 1's = No Special Weights
# Rank Method: Themes: Average
#              Index: (("Environmental Effects"+"Environmental Exposures")/2)*
#                     (("Socioeconomic Factors"+"Sensitive Populations")/2)
# Read Data Extract (3-Sheets)
message('reading')
extract_measure <- read_xlsx(file.path(dir,path), sheet = "Measure",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'guess',
'guess', 'guess', 'guess',
'guess')) %>% as.data.table
extract_theme <- read_xlsx(file.path(dir,path), sheet = "Theme",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'numeric',
'guess', 'guess')) %>% as.data.table
extract_index <- read_xlsx(file.path(dir,path), sheet = "Index",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'guess',
'guess', 'guess')) %>% as.data.table
# Clean Data Extract Data
# Apply Weights If Not = 1
message('cleaning')
measure_dt <- extract_measure %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[rank==-1, rank := NA] %>%
.[rankcalculatedvalue==-1, rankcalculatedvalue := NA] %>%
.[, .(geocode, item=itemname, theme=themename, measure_rank=rank,
measure_rank_val=rankcalculatedvalue)]
index_dt <- extract_index %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[, .(geocode, index_rank=rank, index_rank_val=rankcalculatedvalue)]
theme_dt <- extract_theme %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[, theme_weights := 1] %>%
.[themename=="Environmental Effects", theme_weights := .5] %>%
.[, .(geocode, theme=themename, theme_weights,
theme_rank_val=rankcalculatedvalue, theme_rank=rank)] %>%
merge(index_dt, by='geocode') #merge on index information
# Remap item names
if(clean_names %>% is.data.table) {
measure_dt <- setnames(measure_dt, 'item', 'item_old') %>%
merge(item_map, by='item_old')
}
# Calculate Ranks: Data Measures
message('calculating measure ranks')
measure_ranks <- measure_dt[, item := factor(item)] %>%
.[, rank_order := frank(measure_rank_val,
na.last='keep',
ties.method = 'min'), by=item] %>%
.[, bin_size := floor(sum(!is.na(measure_rank_val))/nranks), by=item] %>%
#bin the ranks and number them by rounding up
.[, measure_rank_integer := (rank_order / bin_size) %>% ceiling, by=item] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[measure_rank_integer>nranks, measure_rank_integer := nranks] %>%
setnafill(type='const', fill=-1, cols=c('measure_rank_val',
'measure_rank_integer',
'measure_rank')) %>%
.[, qa_measures := measure_rank == measure_rank_integer] #verify that calcs match published
# Calculate Ranks: Themes
#crossjoin to create all combos of geocode and theme+name
#thene fill with 0s
message('calculating theme ranks')
theme_ranks <- measure_dt[, CJ(geocode, item, unique=T), by=theme] %>%
merge(measure_dt, by=c('geocode', 'item', 'theme'), all.x=T) %>%
merge(theme_dt, by=c('geocode', 'theme')) %>%
# Missing Tracts Are Added To Measures With A Measure Rank = 0
setnafill(., type='const', fill=0, cols=names(.) %>% .[.%like%'rank']) %>%
.[, measure_num := .N, by=.(geocode, theme)] %>%
.[, measure_rank_sum := sum(measure_rank_integer), by=.(geocode, theme)] %>%
.[, measure_rank_sum := sum(measure_rank_integer), by=.(geocode, theme)] %>%
unique(., by=c('geocode', 'theme')) %>%
#TODO ranking could be better as a function??
.[, theme_avg_rank := round_half_up(measure_rank_sum/measure_num, 2), by=theme] %>%
.[, theme_rank_order := frank(theme_avg_rank,
na.last='keep',
ties.method = 'min'), by=theme] %>%
.[, theme_bin_size := floor(sum(!is.na(theme_avg_rank))/nranks), by=theme] %>%
#bin the ranks and number them by rounding up
.[, theme_rank_integer := (theme_rank_order / theme_bin_size) %>% ceiling, by=theme] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[theme_rank_integer>nranks, theme_rank_integer := nranks] %>%
.[, qa_themes := theme_rank == theme_rank_integer] #verify that calcs match published
# Calculate Ranks: Index
# File Details Above Indicates Theme "Environmental Effects" is Weighted At 0.5 And
# The Rank Method = (("Environmental Effects"+"Environmental Exposures")/2)*
#                     (("Socioeconomic Factors"+"Sensitive Populations")/2)
# The First Sum In This Method = The Pollution Burden, The Second = Population Characteristics
# The Theme Field We Start With = calc_theme_avg_measure_ranks
message('calculating index ranks')
index_ranks <- setorder(theme_ranks, geocode, theme) %>%
.[, weighted_ranks := theme_avg_rank * theme_weights] %>%
.[theme%like%'Environmental', burden_sum := sum(weighted_ranks), by=geocode] %>%
setnafill(type='locf', cols='burden_sum') %>%  #env ordered first, so carry fwd
.[theme%like%'Environmental', burden_avg := mean(weighted_ranks), by=geocode] %>%
setnafill(type='locf', cols='burden_avg') %>%  #env ordered first, so carry fwd
.[!(theme%like%'Environmental'), pop_chars := sum(weighted_ranks), by=geocode] %>%
setnafill(type='nocb', cols='pop_chars') %>%  #env ordered first, so carry back
.[!(theme%like%'Environmental'), pop_avg := mean(weighted_ranks), by=geocode] %>%
setnafill(type='nocb', cols='pop_avg') %>%  #env ordered first, so carry back
unique(., by=c('geocode')) %>%
#scale both per cal enviroscreen standard
#.[, burden_scaled := burden_avg / max(burden_avg) * 10] %>%
.[, burden_scaled := scale(burden_avg)] %>%
#.[, pop_scaled := pop_avg / max(pop_avg) * 10] %>%
.[, pop_scaled := scale(pop_avg)] %>%
#TODO ranking could be better as a function??
.[, index_avg_rank := round_half_up(burden_sum/2*pop_chars/2,
2)] %>%
.[, index_rank_cal := burden_avg * pop_avg] %>%
#.[order(index_avg_rank), index_rank_int := floor( 1 + nranks * (.I-1)/.N)] %>%
.[, index_rank_order := frank(index_avg_rank,
na.last='keep',
ties.method = 'min')] %>%
.[, index_bin_size := floor(sum(!is.na(index_avg_rank))/nranks)] %>%
#bin the ranks and number them by rounding up
.[, index_rank_integer := (index_rank_order / index_bin_size) %>% ceiling] %>%
.[index_rank_integer>nranks, index_rank_integer := nranks] %>%
#redo everything with the scaled cal method
.[, index_rank_order := frank(index_rank_cal,
na.last='keep',
ties.method = 'min')] %>%
.[, index_bin_size := floor(sum(!is.na(index_rank_cal))/nranks)] %>%
#bin the ranks and number them by rounding up
.[, index_rank_integer_cal := (index_rank_order / index_bin_size) %>% ceiling] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[index_rank_integer>nranks, index_rank_integer := nranks] %>%
.[index_rank_integer_cal>nranks, index_rank_integer_cal := nranks] %>%
.[, qa_index := index_rank == index_rank_integer] #verify that calcs match published
list('measure'=measure_ranks,
'theme'=theme_ranks,
'index'=index_ranks,
'measure_raw'=measure_dt) %>%
return
}
ranks_old <- cleanAndRank(dir=local.dir, path=data_extract_EHDv1, clean_names=item_map, debug=F)
ranks_new <- cleanAndRank(dir=local.dir, path=data_extract_EHDv2)
#merge measures (old v. new) to compare
measure_ranks <- merge(ranks_old$measure[, .(geocode, item, theme,
measure_old=measure_rank_integer)],
ranks_new$measure[, .(geocode, item, theme,
measure_new=measure_rank_integer),],
by=c('geocode', 'item', 'theme'), all = T) %>%
.[, measure_shift := measure_new-measure_old] %>%
.[, avg_shift := mean(measure_shift, na.rm=T), by='item'] %>%
.[, measure_old_neg := measure_old * -1] %>%
.[, measure_shift_capped := measure_shift] %>%
.[measure_shift>=5, measure_shift_capped := 5] %>%
.[measure_shift<=-5, measure_shift_capped := -5]
#merge raw measures (old v. new) to compare
measure_raw <- merge(ranks_old$measure_raw[, .(geocode, item, theme,
measure_old=measure_rank_val)],
ranks_new$measure[, .(geocode, item, theme,
measure_new=measure_rank_val)],
by=c('geocode', 'item', 'theme'), all=T) %>%
.[, measure_shift_raw := measure_new-measure_old] %>%
.[, avg_shift := mean(measure_shift_raw, na.rm=T), by='item'] %>%
.[, measure_old_neg := measure_old * -1] %>%
setnames(., c('measure_new', 'measure_old'), c('measure_new_raw', 'measure_old_raw'))
#merge themes
theme_dt <- merge(ranks_old$theme[, .(geocode, item, theme,
index_old=theme_rank_integer)],
ranks_new$theme[, .(geocode, item, theme,
index_new=theme_rank_integer)],
by=c('geocode', 'item', 'theme')) %>%
.[, index_shift := index_new-index_old] %>%
.[, index_old_neg := index_old * -1] %>%
.[, index_shift_capped := index_shift] %>%
.[index_shift>=5, index_shift_capped := 5] %>%
.[index_shift<=-5, index_shift_capped := -5]
#merge indexes (old v. new) to compare
index_dt <- merge(ranks_old$index[, .(geocode, item, theme,
index_old=index_rank_integer)],
ranks_new$index[, .(geocode, item, theme,
index_new=index_rank_integer,
index_new_cal=index_rank_integer_cal)],
by=c('geocode', 'item', 'theme')) %>%
.[, scaling_effect := index_new/index_new_cal] %>%
.[, index_shift := index_new-index_old] %>%
.[, index_old_neg := index_old * -1] %>%
.[, index_shift_capped := index_shift] %>%
.[index_shift>=5, index_shift_capped := 5] %>%
.[index_shift<=-5, index_shift_capped := -5]
#identify dropouts
threshold_val <- 9
index_dt[, impacted_new := 0]
index_dt[, impacted_old := 0]
index_dt[index_new>=threshold_val, impacted_new := 1]
index_dt[index_old>=threshold_val, impacted_old := 1]
index_dt[, dropout := as.factor(impacted_old - impacted_new)]
index_dt[, GEOID10 := as.character(geocode)]
#merge the dropouts back onto the other tables for graphing
measure_ranks <- merge(measure_ranks, index_dt[, .(geocode, dropout)], by='geocode')
#drop water codes with weird data from maps
drop_geocodes <- c('53057990100' #san juan water area with lots of big changes
)
#add life expectancy data
index_dt[, geocode_chr := geocode %>% as.character]
index_dt <- merge(index_dt, le_dt, by.x='geocode_chr', by.y='geocode')
index_dt[, le_state_average := mean(le, na.rm=T)]
is_outlier <- function(x) {
return(x < quantile(x, 0.25, na.rm=T) - 1.5 * IQR(x, na.rm=T) | x > quantile(x, 0.75, na.rm=T) + 1.5 * IQR(x, na.rm=T))
}
#label the outliers
index_dt[, outlier_lab := ifelse(is_outlier(le), name, NA_character_), by=index_new]
#scaling effect basic scatterplot
ggplot(index_dt, aes(x=index_new, y=index_new_cal, color=scaling_effect) ) +
geom_point(position='jitter') +
#geom_hex(bins = 70) +
scale_color_viridis(option='magma') +
theme_bw()
# ---FUNCTIONS----------------------------------------------------------------------------------------------------------
#test space
cleanAndRank <- function(dir, path,
nranks=10,
clean_names=F,
debug=F) {
if(debug) browser()
# File Details:
# Weights: Measures: All 1's = No Special Weights
#          Themes: "Environmental Effects" = .5, Other Themes Are 1's = No Special Weights
# Rank Method: Themes: Average
#              Index: (("Environmental Effects"+"Environmental Exposures")/2)*
#                     (("Socioeconomic Factors"+"Sensitive Populations")/2)
# Read Data Extract (3-Sheets)
message('reading')
extract_measure <- read_xlsx(file.path(dir,path), sheet = "Measure",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'guess',
'guess', 'guess', 'guess',
'guess')) %>% as.data.table
extract_theme <- read_xlsx(file.path(dir,path), sheet = "Theme",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'numeric',
'guess', 'guess')) %>% as.data.table
extract_index <- read_xlsx(file.path(dir,path), sheet = "Index",
col_types=c('numeric', 'numeric', 'numeric',
'guess', 'guess', 'guess',
'guess', 'guess')) %>% as.data.table
# Clean Data Extract Data
# Apply Weights If Not = 1
message('cleaning')
measure_dt <- extract_measure %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[rank==-1, rank := NA] %>%
.[rankcalculatedvalue==-1, rankcalculatedvalue := NA] %>%
.[, .(geocode, item=itemname, theme=themename, measure_rank=rank,
measure_rank_val=rankcalculatedvalue)]
index_dt <- extract_index %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[, .(geocode, index_rank=rank, index_rank_val=rankcalculatedvalue)]
theme_dt <- extract_theme %>%
setnames(., names(.), names(.) %>% tolower) %>%
.[, theme_weights := 1] %>%
.[themename=="Environmental Effects", theme_weights := .5] %>%
.[, .(geocode, theme=themename, theme_weights,
theme_rank_val=rankcalculatedvalue, theme_rank=rank)] %>%
merge(index_dt, by='geocode') #merge on index information
# Remap item names
if(clean_names %>% is.data.table) {
measure_dt <- setnames(measure_dt, 'item', 'item_old') %>%
merge(item_map, by='item_old')
}
# Calculate Ranks: Data Measures
message('calculating measure ranks')
measure_ranks <- measure_dt[, item := factor(item)] %>%
.[, rank_order := frank(measure_rank_val,
na.last='keep',
ties.method = 'min'), by=item] %>%
.[, bin_size := floor(sum(!is.na(measure_rank_val))/nranks), by=item] %>%
#bin the ranks and number them by rounding up
.[, measure_rank_integer := (rank_order / bin_size) %>% ceiling, by=item] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[measure_rank_integer>nranks, measure_rank_integer := nranks] %>%
setnafill(type='const', fill=-1, cols=c('measure_rank_val',
'measure_rank_integer',
'measure_rank')) %>%
.[, qa_measures := measure_rank == measure_rank_integer] #verify that calcs match published
# Calculate Ranks: Themes
#crossjoin to create all combos of geocode and theme+name
#thene fill with 0s
message('calculating theme ranks')
theme_ranks <- measure_dt[, CJ(geocode, item, unique=T), by=theme] %>%
merge(measure_dt, by=c('geocode', 'item', 'theme'), all.x=T) %>%
merge(theme_dt, by=c('geocode', 'theme')) %>%
# Missing Tracts Are Added To Measures With A Measure Rank = 0
setnafill(., type='const', fill=0, cols=names(.) %>% .[.%like%'rank']) %>%
.[, measure_num := .N, by=.(geocode, theme)] %>%
.[, measure_rank_sum := sum(measure_rank_integer), by=.(geocode, theme)] %>%
.[, measure_rank_sum := sum(measure_rank_integer), by=.(geocode, theme)] %>%
unique(., by=c('geocode', 'theme')) %>%
#TODO ranking could be better as a function??
.[, theme_avg_rank := round_half_up(measure_rank_sum/measure_num, 2), by=theme] %>%
.[, theme_rank_order := frank(theme_avg_rank,
na.last='keep',
ties.method = 'min'), by=theme] %>%
.[, theme_bin_size := floor(sum(!is.na(theme_avg_rank))/nranks), by=theme] %>%
#bin the ranks and number them by rounding up
.[, theme_rank_integer := (theme_rank_order / theme_bin_size) %>% ceiling, by=theme] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[theme_rank_integer>nranks, theme_rank_integer := nranks] %>%
.[, qa_themes := theme_rank == theme_rank_integer] #verify that calcs match published
# Calculate Ranks: Index
# File Details Above Indicates Theme "Environmental Effects" is Weighted At 0.5 And
# The Rank Method = (("Environmental Effects"+"Environmental Exposures")/2)*
#                     (("Socioeconomic Factors"+"Sensitive Populations")/2)
# The First Sum In This Method = The Pollution Burden, The Second = Population Characteristics
# The Theme Field We Start With = calc_theme_avg_measure_ranks
message('calculating index ranks')
index_ranks <- setorder(theme_ranks, geocode, theme) %>%
.[, weighted_ranks := theme_avg_rank * theme_weights] %>%
.[theme%like%'Environmental', burden_sum := sum(weighted_ranks), by=geocode] %>%
setnafill(type='locf', cols='burden_sum') %>%  #env ordered first, so carry fwd
.[theme%like%'Environmental', burden_avg := mean(weighted_ranks), by=geocode] %>%
setnafill(type='locf', cols='burden_avg') %>%  #env ordered first, so carry fwd
.[!(theme%like%'Environmental'), pop_chars := sum(weighted_ranks), by=geocode] %>%
setnafill(type='nocb', cols='pop_chars') %>%  #env ordered first, so carry back
.[!(theme%like%'Environmental'), pop_avg := mean(weighted_ranks), by=geocode] %>%
setnafill(type='nocb', cols='pop_avg') %>%  #env ordered first, so carry back
unique(., by=c('geocode')) %>%
#scale both per cal enviroscreen standard
.[, burden_scaled := burden_avg / max(burden_avg) * 10] %>%
.[, pop_scaled := pop_avg / max(pop_avg) * 10] %>%
#TODO ranking could be better as a function??
.[, index_avg_rank := round_half_up(burden_sum/2*pop_chars/2,
2)] %>%
.[, index_rank_cal := burden_avg * pop_avg] %>%
#.[order(index_avg_rank), index_rank_int := floor( 1 + nranks * (.I-1)/.N)] %>%
.[, index_rank_order := frank(index_avg_rank,
na.last='keep',
ties.method = 'min')] %>%
.[, index_bin_size := floor(sum(!is.na(index_avg_rank))/nranks)] %>%
#bin the ranks and number them by rounding up
.[, index_rank_integer := (index_rank_order / index_bin_size) %>% ceiling] %>%
.[index_rank_integer>nranks, index_rank_integer := nranks] %>%
#redo everything with the scaled cal method
.[, index_rank_order := frank(index_rank_cal,
na.last='keep',
ties.method = 'min')] %>%
.[, index_bin_size := floor(sum(!is.na(index_rank_cal))/nranks)] %>%
#bin the ranks and number them by rounding up
.[, index_rank_integer_cal := (index_rank_order / index_bin_size) %>% ceiling] %>%
# Non-Missing Tract's WIth NA's Are Given A Measure Rank = -1
.[index_rank_integer>nranks, index_rank_integer := nranks] %>%
.[index_rank_integer_cal>nranks, index_rank_integer_cal := nranks] %>%
.[, qa_index := index_rank == index_rank_integer] #verify that calcs match published
list('measure'=measure_ranks,
'theme'=theme_ranks,
'index'=index_ranks,
'measure_raw'=measure_dt) %>%
return
}
ranks_old <- cleanAndRank(dir=local.dir, path=data_extract_EHDv1, clean_names=item_map, debug=F)
ranks_new <- cleanAndRank(dir=local.dir, path=data_extract_EHDv2)
#merge measures (old v. new) to compare
measure_ranks <- merge(ranks_old$measure[, .(geocode, item, theme,
measure_old=measure_rank_integer)],
ranks_new$measure[, .(geocode, item, theme,
measure_new=measure_rank_integer),],
by=c('geocode', 'item', 'theme'), all = T) %>%
.[, measure_shift := measure_new-measure_old] %>%
.[, avg_shift := mean(measure_shift, na.rm=T), by='item'] %>%
.[, measure_old_neg := measure_old * -1] %>%
.[, measure_shift_capped := measure_shift] %>%
.[measure_shift>=5, measure_shift_capped := 5] %>%
.[measure_shift<=-5, measure_shift_capped := -5]
#merge raw measures (old v. new) to compare
measure_raw <- merge(ranks_old$measure_raw[, .(geocode, item, theme,
measure_old=measure_rank_val)],
ranks_new$measure[, .(geocode, item, theme,
measure_new=measure_rank_val)],
by=c('geocode', 'item', 'theme'), all=T) %>%
.[, measure_shift_raw := measure_new-measure_old] %>%
.[, avg_shift := mean(measure_shift_raw, na.rm=T), by='item'] %>%
.[, measure_old_neg := measure_old * -1] %>%
setnames(., c('measure_new', 'measure_old'), c('measure_new_raw', 'measure_old_raw'))
#merge themes
theme_dt <- merge(ranks_old$theme[, .(geocode, item, theme,
index_old=theme_rank_integer)],
ranks_new$theme[, .(geocode, item, theme,
index_new=theme_rank_integer)],
by=c('geocode', 'item', 'theme')) %>%
.[, index_shift := index_new-index_old] %>%
.[, index_old_neg := index_old * -1] %>%
.[, index_shift_capped := index_shift] %>%
.[index_shift>=5, index_shift_capped := 5] %>%
.[index_shift<=-5, index_shift_capped := -5]
#merge indexes (old v. new) to compare
index_dt <- merge(ranks_old$index[, .(geocode, item, theme,
index_old=index_rank_integer)],
ranks_new$index[, .(geocode, item, theme,
index_new=index_rank_integer,
index_new_cal=index_rank_integer_cal)],
by=c('geocode', 'item', 'theme')) %>%
.[, scaling_effect := index_new/index_new_cal] %>%
.[, index_shift := index_new-index_old] %>%
.[, index_old_neg := index_old * -1] %>%
.[, index_shift_capped := index_shift] %>%
.[index_shift>=5, index_shift_capped := 5] %>%
.[index_shift<=-5, index_shift_capped := -5]
#identify dropouts
threshold_val <- 9
index_dt[, impacted_new := 0]
index_dt[, impacted_old := 0]
index_dt[index_new>=threshold_val, impacted_new := 1]
index_dt[index_old>=threshold_val, impacted_old := 1]
index_dt[, dropout := as.factor(impacted_old - impacted_new)]
index_dt[, GEOID10 := as.character(geocode)]
#merge the dropouts back onto the other tables for graphing
measure_ranks <- merge(measure_ranks, index_dt[, .(geocode, dropout)], by='geocode')
#drop water codes with weird data from maps
drop_geocodes <- c('53057990100' #san juan water area with lots of big changes
)
#add life expectancy data
index_dt[, geocode_chr := geocode %>% as.character]
index_dt <- merge(index_dt, le_dt, by.x='geocode_chr', by.y='geocode')
index_dt[, le_state_average := mean(le, na.rm=T)]
is_outlier <- function(x) {
return(x < quantile(x, 0.25, na.rm=T) - 1.5 * IQR(x, na.rm=T) | x > quantile(x, 0.75, na.rm=T) + 1.5 * IQR(x, na.rm=T))
}
#label the outliers
index_dt[, outlier_lab := ifelse(is_outlier(le), name, NA_character_), by=index_new]
#scaling effect basic scatterplot
ggplot(index_dt, aes(x=index_new, y=index_new_cal, color=scaling_effect) ) +
geom_point(position='jitter') +
#geom_hex(bins = 70) +
scale_color_viridis(option='magma') +
theme_bw()
# ----CONFIG------------------------------------------------------------------------------------------------------------
# clear memory
rm(list=ls())
install.packages('devtools')
install.packages("devtools")
install.packages("devtools")
install.packages("devtools")
remove.packages('cli')
install.packages("devtools")
install.packages("devtools")
sessionInfo()
sessionInfo()
# ----HEADER------------------------------------------------------------------------------------------------------------
# Author: JF
# Date: 01/18/2023
# Purpose: Prepare datasets and run delivery costs analysis
# source("/homes/jfrostad/_code/start/ipm/delivery_costs/calc.R", echo=T)
#***********************************************************************************************************************
# ----CONFIG------------------------------------------------------------------------------------------------------------
# clear memory
rm(list=ls())
#set opts
set.seed(98118)
options(scipen=999) #readability
#use cairo to render instead of quartz (quartz causes big slowdowns with geom_sf)
if(!identical(getOption("bitmapType"), "cairo") && isTRUE(capabilities()[["cairo"]])){
options(bitmapType = "cairo")
}
#set control flow params
reload <- T #set true if you want to reprep all the data
disease <- 'Schisto'
## Set core_repo locations
user            <- Sys.info()['user']
box_name        <- 'Joseph Frostad' #TODO find out how to pull this relative
local_dir       <- ifelse(Sys.info()["sysname"] == "Linux",
file.path('/homes', user, ''),
file.path('C:/Users', user, 'Documents/start/ipm/delivery_costs/'))
my_repo <- file.path(local_dir, 'repo')
my_dropbox <- file.path('C:/Users', user, 'UW START Dropbox', box_name, '/INTERNAL IPM Vx Valuations/NTD 2022')
setwd(my_repo)
#TODO categorize and comment packages
#TODO cleanup here
pacman::p_load(readxl, janitor, data.table, naniar, dplyr, stringr, magrittr, #data wrangling
scales, ggplot2, ggridges, ggrepel, gridExtra, RColorBrewer, viridis, #viz
plm, lme4, #modelling tools
stargazer, #sig tables
#caret, mlbench, randomForest, pls, #ML tools
zoo)
#***********************************************************************************************************************
# ----IN/OUT------------------------------------------------------------------------------------------------------------
###Input###
code_dir <- file.path(my_repo, 'code')
data_dir <- file.path(local_dir, 'data')
#TODO consider which data is universal and which is by disease. How to organize
model_data_dir <- file.path(my_dropbox, '/1 - Data gathering - all diseases/Costs/Delivery costs/')
coef_path <- "Delivery_cost_regression_coefficients_to_use_7_12_2022.csv" #TODO rename
#also load the central model objs received from fitzpatrick
load(file.path(data_dir, 'benchmark.Rdata'), verbose=T)
#ihme data
ihme_version <- '2022-09-13'
ihme_data_dir <- file.path(my_dropbox, 'IHME', ihme_version)
pop_path <- 'IU_pop_dens_all_age.csv'
